# Testing Setup for Meet-the-Neighbors

## Overview

This document explains the pytest test suite created from the notebook functions in `mtn_tests.ipynb`. The tests validate core functionality of the meet-the-neighbors package in a way that's reproducible, automatable, and suitable for CI/CD pipelines.

## Directory Structure

```
tests/
├── __init__.py                          # Makes tests a package
├── conftest.py                          # Pytest configuration & shared fixtures
├── test_main.py                         # All test cases (3 test classes, 5 test runs)
├── create_test_data.py                  # Script to generate nnhash_mapping.obj
└── test_data/
    ├── test_query_fasta
    │   ├── output of extract_neighbors or predictvfs mtn mode run with query fasta                   
    │   └── output of extract_neighbors or predictvfs mtn mode run with genomes
```

## Running the Tests

### Prerequisites

```bash
conda activate meetneighbors  # or your environment name
```

### Run All Tests

```bash
cd /path/to/meet-the-neighbors
pytest tests/
```

### Run Specific Test Class

```bash
pytest tests/test_main.py::TestGLMInputValidation
pytest tests/test_main.py::TestQueryRepMapping
pytest tests/test_main.py::TestComputeUMAP
```

### Run with Verbose Output

```bash
pytest tests/ -v
```

Shows test names and their parametrization clearly.

### Run with Output

```bash
pytest tests/ -s
```

Displays all print statements and debug output.

## Test Classes & What They Validate

### 1. TestGLMInputValidation

**Purpose:** Validates GLM (gLM) input file consistency

**Tests:**
- `test_glm_inputs()` - Runs 2x (parametrized for VF001.tsv, VF002.tsv)

**Validations:**
- All gene IDs (rep values) in glm_input exist in mmseqs clustering results
- Gene ID order matches between glm_input and mmseqs_clust
- VF center index points to valid protein in neighborhood

### 2. TestQueryRepMapping

**Purpose:** Validates protein query-to-representative mappings

**Tests:**
- `test_query_rep_mapping()` - Runs 1x

**Validations:**
- All query proteins map to valid representative proteins
- Mappings are consistent with original clustering results
- Each query maps to exactly one rep (1:1 relationship)
- All reps exist in clustering results

### 3. TestComputeUMAP

**Purpose:** Validates data structure for UMAP visualization

**Tests:**
- `test_computeumap()` - Runs 2x (parametrized for VF001.tsv, VF002.tsv)

**Validations:**
- All neighborhoods in input exist in clustering results
- All proteins referenced in input exist in clustering results
- Neighborhood sizes within bounds (3-30 proteins)
- VF center index within valid bounds for each neighborhood

## Test Fixtures (conftest.py)

### Session-Scope Fixtures (cached for all tests)

These are loaded once per test session and reused:

- **`test_data_dir`** → Path to test_data/ directory
- **`mmseqs_clust_res`** → DataFrame with clustering results
- **`og_mmseqs_clust`** → DataFrame with original pre-neighborhood clustering
- **`nn_hash_obj`** → Dict mapping hashes to query-rep-neighborhood tuples

### Function-Scope Fixtures (parametrized)

These are created fresh for each test function:

- **`glm_input_df`** → Parametrized fixture loading VF001.tsv or VF002.tsv
  - Parametrization: `['VF001', 'VF002']`
  - This causes dependent tests to run 2x total (once per parameter)

## Test Data Files

### glm_inputs/VF001.tsv & VF002.tsv

Format: Tab-separated, no header

Columns (in order):
1. `neighborhood_name` - Unique neighborhood ID
2. `rep` - Semicolon-delimited protein IDs with strand (e.g., `+ABC123;+DEF456`)
3. `vf_center_index` - 0-based index of VF center protein in the rep list

Example (VF001.tsv):
```
VF001!!!ref001!!!0.95!!!1000-2000	+ABC123;+DEF456;+GHI789	0
VF001!!!ref002!!!0.95!!!3000-4000	+JKL012;+MNO345;+PQR678	1
```

### mmseqs_clust.tsv

Format: Tab-separated with header

Contains all proteins and their clustering/neighborhood information:
- `rep` - Cluster representative protein ID
- `neighborhood_name` - Which neighborhood this protein belongs to
- `start` - Genomic start position (used for sorting)
- `query` - Query protein (for grouping)
- Plus other metadata columns

### combined_fastas_clust_res.tsv

Format: Tab-separated with header

Original clustering before neighborhood assignment:
- `rep` - Representative protein ID
- `locus_tag` - Full protein identifier

Used to validate that queries map consistently to reps.

### nnhash_mapping.obj

Format: Python pickle file

Dictionary structure:
```python
{
    'hash_0': [('query1', 'rep1', 'nn1')],
    'hash_1': [('query2', 'rep2', 'nn2')],
    ...
}
```

Maps hash values to lists of (query, rep, neighborhood_name) tuples.

Auto-generated by conftest.py if missing.

## Adding Your Own Test Data

When you have real/minimal synthetic test data you want to use instead:

1. **glm_inputs files:**
   - Add TSV files to `tests/test_data/glm_inputs/`
   - Update fixture parametrization in `conftest.py`:
     ```python
     @pytest.fixture(params=['VF001', 'VF002', 'your_new_file'])
     def glm_input_df(request, test_data_dir):
     ```
   - This will automatically run all tests parametrized on the new file

2. **mmseqs_clust.tsv:**
   - Replace the file in `tests/test_data/`
   - Ensure all protein IDs from your glm_inputs files are present
   - Keep column names and order consistent

3. **combined_fastas_clust_res.tsv:**
   - Replace with your original pre-neighborhood clustering
   - Used for validation that new clustering maintains consistency

4. **nnhash_mapping.obj:**
   - Run `python tests/create_test_data.py` to auto-generate
   - Or create custom pickle file with your mapping data

## GitHub Actions Integration

While this setup doesn't include a GitHub Actions workflow (as requested), you can easily add one later:

```yaml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install pytest pandas
      - name: Run tests
        run: pytest tests/ -v
```

Save this as `.github/workflows/pytest.yml` when ready.

## Troubleshooting

### Test discovery fails
- Ensure `tests/__init__.py` exists (it does)
- Check pytest is installed: `pip install pytest`
- Run from workspace root directory

### Fixture not found errors
- Verify `conftest.py` is in `tests/` directory
- Check for syntax errors: `python -m py_compile tests/conftest.py`

### Test data not found
- Verify files exist in `tests/test_data/`
- Check file paths match exactly in conftest.py
- Verify permissions: `ls -la tests/test_data/`

### Parameterization not working
- Ensure `@pytest.fixture(params=[...])` decorator is present
- List parameters as list of strings, not tuples
- Run with `pytest -v` to see parametrized test names

## Summary

- **3 test classes** with clearly separated concerns
- **5 total test runs** (2 tests parametrized 2x, 1 test not parametrized)
- **Fixtures at 2 scopes:** session (efficient) and function (with parametrization)
- **Minimal synthetic test data** that validates core logic without heavy dependencies
- **Ready for automation** - can be integrated into CI/CD at any time
- **Extensible** - easy to add new test cases by adding files to test_data/ and updating fixture params
